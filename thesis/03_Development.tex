
\section{Development}
Since IME is a complicated environment, has been chosen to develop the simulator 
using an iterative approach. This allowed an understanding of the whole system
showing a single part at a time, at the cost of creating prototypes that needed
to be rewritten partially or completely. \\
To speed up this prototyping approach has been used the Dot language \cite{dot-lang} to 
quickly develop finite state machines that will have been later implemented.

\subsection{Environment choice}
Based on the conditions explained in the introduction (see section
\ref{requirements}), \textit{Python} seemed a reasonable choice. Mostly because
of its flexibility to changes, not worrying about small detail like memory
addresses and garbage collection. Since this applications is not computationally
intensive, not involving any kind of floating point operation, the cost of an
interpreted language is not so high. \\
Moreover modern features coming from Python 3.5+ made easier to develop a
relatively big applications as this simulator is, like types annotations and
better generators support.

\subsection{Tools Chosen}
\begin{itemize}
    \item Dot graphs
    \item SimPy
    \item PyPy
    \item vmprof \& Flamegraph
\end{itemize}


\subsection{Simpy}\label{simpy}
Simpy is the library the projects is based on. It is a Discrete Simulation
library that fulfill the requirements. Exploiting language mechanics like
generators does not add overhead on the application. It is process-based
meaning that every task can be scheduled as a process, not waiting for others
task to be completed. The library is anyway serial, not creating threads by
itself. Anyway it can be integrated using other libraries, like \textit{threading} (see
\cite{threading}), but so far the simulation achieve reasonable wall times,
there is no need to parallelize it.
Simpy offer a framework in which our routines are executed and tracked. The
status of an agent inside the system is tracked using python generators,
lazy iterators that generate the requested iterator only when needed. Because of
the framework environment we need specific functions that returns a generator
Simpy can take care of and others that keep track of the system status. Simpy
functions can return generators to make the virtual clock going on, create other
virtual processes or wait for other processes to be completed, according to the
situation. The other set of functions are those that implement the system's logic.

\subsection{SimPy Components}
The philosophy of Simpy led to the development of some ready-to-use components
that ease the process management like mutex and task queues.
Anyway Simpy provides only tools to manage the processes, lacking some
structures to extract usage data to investigate at the end of the simulation.
For this reason some more tools has been developed both in Python, for internal
simulation data extraction, and Bash to automate plotting and file management.

\subsubsection*{Timeout}
The library has some predefined events like a \textit{Timeout} event that just
simulates time passing for the caller.\\
This call blocks only the calling agent, allowing every other event already
triggered to be processed correctly. \\
Every real time consuming action is simulated through this function: the call
with the correct amount of time will make the calling agent to wait until the
task is virtually completed.

\subsubsection*{Resources}
In every simulation environment there are components that needs to be accessed
by many agents and to process correctly this resource contention. This means
keeping a queue of every agent and trigger one as a resource is freed. \\
SimPy takes care of this queue management, providing many types of resources,
fitting many needs.
\begin{itemize}
    \item \textbf{Resource} \cite{simpy-resource}: 
        allows multiple agents to access this tool at the same time. A
        request to this resource is blocked if the quantity of agents using it
        is already at the maximum value. The maximum number of agents
        can be set in its constructor. Setting \texttt{capacity = 1} means this
        resource will behave as a mutex. \\
        An example is accessing a disk to write a file: only a single file can be
        written at once, so the device's resource will have a capacity set to 1.
        The writing process must obtain access to this resource before
        proceeding further. \\
        \begin{myimage}{resource}{Resource request management}
            Request management using simpy.Container. A \textit{Resource} with
            still space accepts a new request (left). A full one rejects the
            request instead (right)
        \end{myimage}
        As shown in Figure \ref{eq:resource} the requests are accepted based on
        the current load of the resource. If there is still room for another
        request, as happens in the left case, the request is accepted. \\
        Otherwise if the request is completely filled, the request is blocked
        until some of the already occupying request free the resource.
    \item \textbf{Container} \cite{simpy-container}: whereas the "Resource"
        tracks the number of accesses to a resource, the container is concerned
        about the quantity of a resource stored. As a container cannot store
        bigger amount of goods than its size and cannot give more than it has
        stored already.  \\
        An example is shown if Figure \ref{eq:container} where different put and
        get requests are performed. Put requests (on the right) are allowed if
        there is enough space, get requests are allowed if there is enough good
        stored. \\
        As a side note, the library still lack custom callback implementation to
        handle blocked requests. This means that there is not the possibility to
        perform some actions if a container is too full, blocking some requests.
        This forces to not fully rely on SimPy classes and implement custom 
        solutions that benefits from these callbacks.
        \begin{myimage}{container}{Container Request management}
            A simpy container with a capacity of 100. On the left the requests
            to put a good in the \textit{Container}, allowed only if there is
            enough space. On the right the get requests, allowed only if there
            is enough resource
            currently stored in the container.
        \end{myimage}
\end{itemize}

\subsection{Tools created}
Since SimPy provide only simulation utilities, lacking data gathering components
and plotting, these features has been developed aside. Specifically has been designed:
\begin{itemize}
    \item \textbf{Logger}: in order to gather data about the components, every
        action is registered using a shared object. Every step is registered, in
        terms of time spent on that action or in times an action is performed.
        At the end of the simulation the data gathered are printed to external
        files, allowing parsing and plotting using external resources.
    \item \textbf{Testing environment}: to inspect the behaviour of the system
        should be easy to specify many test cases using different
        configurations. For this reason bash scripts and makefiles has been
        developed to manage the simulator at a higher level. At the end of the
        multiple simulations, plots are generated based on the data gathered
        from each run.
\end{itemize}



\subsection{Profiling}\label{profiling}
Time spending operations are simulates as already specified. The simulator is
not a computationally intensive application but as things start to grow, the
wall time increases. This because of the large amount of data needed to run the
application: a file of 1 GB must be splitted in buckets, network buffer and
finally in \cmloid of size 128 KB. This result in $1GB / 128KB = 8192 \cmloid$
allocated just for a single gigabyte of data written. Some experiments on C
integration has been conducted but the real problem is data allocation and its
management. The usage of suitable data structures for every need plays a key
role in speeding up the simulator. \\
\textit{Talk about xargs and how memory bound the simulator is}


\subsection{Pypy}

\subsection{Object size analysis}
Show the size of a set of data
\begin{itemize}
    \item on their own
    \item in a list
    \item in a class
    \item in a queue
\end{itemize}

\subsection{C integration}
Python is
